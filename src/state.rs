use std::{
    collections::{BTreeMap, HashMap},
    fs,
    path::{Path, PathBuf},
};

use serde::{Deserialize, Serialize};
use thiserror::Error;

use crate::{
    asset_ident::AssetIdent,
    config::{Config, TargetType},
};

static STATE_FILENAME: &str = "runway-state.toml";
static STATE_FILENAME_LOCAL: &str = "runway-state.local.toml";
static HEADER_COMMENT: &str =
    "# This file was @generated by Runway. It is not intended for manual editing.\n";
static LOCAL_COMMENT: &str = "# This file contains local sync state and shouldn't be shared.\n";

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct State {
    pub runway_version: String,
    pub assets: BTreeMap<AssetIdent, AssetState>,
}
impl Default for State {
    fn default() -> Self {
        Self {
            runway_version: env!("CARGO_PKG_VERSION").into(),
            assets: BTreeMap::new(),
        }
    }
}

impl State {
    fn filter_scope(&self, config: &Config, local: bool) -> Self {
        let mut m = self.clone();
        for (_, asset) in m.assets.iter_mut() {
            for target in &config.targets {
                if (target.r#type == TargetType::Local) != local {
                    asset.targets.remove(&target.key);
                }
            }
        }
        m
    }

    fn read_from_file<P: AsRef<Path>>(folder_path: P, filename: &str) -> Result<Self, StateError> {
        let folder_path = folder_path.as_ref();
        let file_path = &folder_path.join(filename);

        let contents = fs::read(file_path)?;
        let config = toml::from_str(&String::from_utf8_lossy(&contents)).map_err(|s| {
            StateError::DeserializeToml {
                source: s,
                path: file_path.to_owned(),
            }
        })?;

        Ok(config)
    }

    // Merge local state and other state
    pub fn read_from_folder<P: AsRef<Path>>(folder_path: P) -> Result<Self, StateError> {
        let mut main_state = match State::read_from_file(&folder_path, STATE_FILENAME) {
            Ok(m) => m,
            Err(e) => {
                if e.is_not_found() {
                    State::default()
                } else {
                    return Err(e.into());
                }
            }
        };
        let local_state = match State::read_from_file(&folder_path, STATE_FILENAME) {
            Ok(m) => m,
            Err(e) => {
                if e.is_not_found() {
                    State::default()
                } else {
                    return Err(e.into());
                }
            }
        };

        // Merge local into main
        for (ident, asset) in main_state.assets.iter_mut() {
            if let Some(local_asset) = local_state.assets.get(&ident) {
                asset.targets.extend(local_asset.targets.clone());
            }
        }

        // Add items only in local to main
        for (ident, asset) in local_state.assets {
            if !main_state.assets.contains_key(&ident) {
                main_state.assets.insert(ident, asset);
            }
        }

        Ok(main_state)
    }

    fn write_to_file<P: AsRef<Path>>(
        &self,
        folder_path: P,
        is_local: bool,
    ) -> Result<(), StateError> {
        match is_local {
            true => {
                let folder_path = folder_path.as_ref();
                let file_path = &folder_path.join(STATE_FILENAME_LOCAL);

                let serialized =
                    HEADER_COMMENT.to_string() + LOCAL_COMMENT + &toml::to_string_pretty(self)?;
                fs::write(file_path, serialized)?;
            }
            false => {
                let folder_path = folder_path.as_ref();
                let file_path = &folder_path.join(STATE_FILENAME);

                let serialized = HEADER_COMMENT.to_string() + &toml::to_string_pretty(self)?;
                fs::write(file_path, serialized)?;
            }
        }
        Ok(())
    }

    pub fn write(&self, config: &Config, folder_path: &Path) -> Result<(), StateError> {
        let main_state = self.filter_scope(&config, false);
        main_state.write_to_file(&folder_path, false)?;

        let local_state = self.filter_scope(&config, true);
        local_state.write_to_file(&folder_path, true)?;

        Ok(())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AssetState {
    pub targets: HashMap<String, TargetState>,
}

// For each asset and target pair, store the hash and ID of the last upload.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TargetState {
    pub hash: String,

    pub id: String,
}

#[derive(Debug, Error)]
pub enum StateError {
    #[error("Error deserializing TOML from path {}", .path.display())]
    DeserializeToml {
        path: PathBuf,
        source: toml::de::Error,
    },

    #[error(transparent)]
    SerializeToml {
        #[from]
        source: toml::ser::Error,
    },

    #[error(transparent)]
    Io {
        #[from]
        source: std::io::Error,
    },
}

impl StateError {
    pub fn is_not_found(&self) -> bool {
        match self {
            StateError::Io { source } => source.kind() == std::io::ErrorKind::NotFound,
            _ => false,
        }
    }
}
