use std::{
    collections::{BTreeMap, HashMap},
    fs,
    path::{Path, PathBuf},
};

use serde::{Deserialize, Serialize};
use thiserror::Error;

use crate::asset_ident::AssetIdent;

static MANIFEST_FILENAME: &str = "runway-manifest.toml";
static HEADER_COMMENT: &str =
    "# This file was @generated by Runway. It is not intended for manual editing.\n";

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Manifest {
    pub runway_version: String,
    pub assets: BTreeMap<AssetIdent, AssetState>,
}

impl Default for Manifest {
    fn default() -> Self {
        Self {
            runway_version: env!("CARGO_PKG_VERSION").into(),
            assets: BTreeMap::new(),
        }
    }
}

impl Manifest {
    pub fn read_from_folder<P: AsRef<Path>>(folder_path: P) -> Result<Self, ManifestError> {
        let folder_path = folder_path.as_ref();
        let file_path = &folder_path.join(MANIFEST_FILENAME);

        let contents = fs::read(file_path)?;
        let config = toml::from_str(&String::from_utf8_lossy(&contents)).map_err(|s| {
            ManifestError::DeserializeToml {
                source: s,
                path: file_path.to_owned(),
            }
        })?;

        Ok(config)
    }

    pub fn write_to_folder<P: AsRef<Path>>(&self, folder_path: P) -> Result<(), ManifestError> {
        let folder_path = folder_path.as_ref();
        let file_path = &folder_path.join(MANIFEST_FILENAME);

        let serialized = HEADER_COMMENT.to_string() + &toml::to_string_pretty(self)?;
        fs::write(file_path, serialized)?;

        Ok(())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AssetState {
    pub targets: HashMap<String, TargetState>,
}

// For each asset and target pair, store the hash and ID of the last upload.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TargetState {
    pub hash: String,

    pub id: String,
}

#[derive(Debug, Error)]
pub enum ManifestError {
    #[error("Error deserializing TOML from path {}", .path.display())]
    DeserializeToml {
        path: PathBuf,
        source: toml::de::Error,
    },

    #[error(transparent)]
    SerializeToml {
        #[from]
        source: toml::ser::Error,
    },

    #[error(transparent)]
    Io {
        #[from]
        source: std::io::Error,
    },
}

impl ManifestError {
    pub fn is_not_found(&self) -> bool {
        match self {
            ManifestError::Io { source } => source.kind() == std::io::ErrorKind::NotFound,
            _ => false,
        }
    }
}
